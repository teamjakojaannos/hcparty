buildscript {
    repositories {
        jcenter()
        maven { url = "http://files.minecraftforge.net/maven" }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.2'
    }
}
apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'org.junit.platform.gradle.plugin'
//Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.

ext.junitPlatformVersion = '1.0.2'
ext.junitJupiterVersion  = '5.0.2'


version = "0.0.0"
group = "jakojaannos.life"
archivesBaseName = "life"

sourceCompatibility = targetCompatibility = '1.8'
compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
}

minecraft {
    version = "1.12.2-14.23.3.2691"
    runDir = "run"
    
    // the mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   snapshot are built nightly.
    // stable_#            stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // simply re-run your setup task after changing the mappings to update your workspace.
    mappings = "snapshot_20171003"
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // Enable dependency ATs
    useDepAts = true


    // Replace info in ModInfo.java
    replace '__VERSION__', project.version

    // Replace API versions
    replace '__VERSION_API_REVIVAL__', '0.0.0'
    replace '__VERSION_API_RESURRECT__', '0.0.0'
}

dependencies {
    // JUnit 5
    testCompile "org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}"
    testRuntime "org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}"

    // Gets rid of warnings about @API annotations when running tests
    testCompileOnly('org.apiguardian:apiguardian-api:1.0.0')
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info and ModInfo.java
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
                
        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }
        
    // copy everything else except the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }

    // Move ATs to META-INF
    rename '(.+_at.cfg)', 'META-INF/$1'
}

// TODO: Instead of reobf'ing and containing the API, include the API to the main jar and ship separate API jar for mod development
//      + doesn't generate the api-jar to the mods directory
//      + allows depending mods to depend on API jar at compile and still have the classes present at runtime
//      - might fuck up setting up dependencies if depending mod doesn't have the main jar at runtime (might be able to setup the main jar as runtime dep and api as compile or sth)
reobf {
    // As only the main jar is normally re-obfuscated, we need to manually mark the API jar for obfuscation
    apiJar {
        mappingType = 'SEARGE'
    }
}

task apiJar(type: Jar, dependsOn: reobfJar) {
    destinationDir = libsDir
    appendix = "api"
    from sourceSets.api.output
}

jar {
    manifest {
        // Tells the FML during load-time that the main jar contains dependencies that should be extracted
        attributes 'ContainedDeps': apiJar.archivePath.name
        attributes 'FMLAT': 'life_at.cfg'
    }

    // Package the API jar inside the main jar
    from (apiJar.archivePath.absolutePath) {
        include '*'
    }
}

build.dependsOn apiJar
